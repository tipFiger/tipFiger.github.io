
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_Hans">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>URL调度器 &#8212; Django 2.1.8.dev20190330215650 文档</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Writing views" href="views.html" />
    <link rel="prev" title="处理 HTTP 请求" href="index.html" />



 
<script type="text/javascript" src="../../templatebuiltins.js"></script>
<script type="text/javascript">
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 2.1.8.dev20190330215650 文档</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="index.html" title="处理 HTTP 请求">previous</a>
     |
    <a href="../index.html" title="Using Django" accesskey="U">up</a>
   |
    <a href="views.html" title="Writing views">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-http-urls">
            
  <div class="section" id="s-url-dispatcher">
<span id="url-dispatcher"></span><h1>URL调度器<a class="headerlink" href="#url-dispatcher" title="永久链接至标题">¶</a></h1>
<p>对于高质量的Web 应用来说，使用简洁、优雅的URL 模式是一个非常值得重视的细节。Django 允许你自由地设计你的URL，不受框架束缚。</p>
<p>参见万维网的发明者Berners-Lee 的 <a class="reference external" href="https://www.w3.org/Provider/Style/URI">Cool URIs don't change</a>，里面有关于为什么URL 应该保持整洁和有意义的卓越论证。</p>
<div class="section" id="s-overview">
<span id="overview"></span><h2>概况<a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h2>
<p>为了给一个应用设计URL，你需要创建一个Python 模块，通常被称为**URLconf**(URL configuration)。这个模块是纯粹的Python 代码，包含URL 模式(简单的正则表达式)到Python 函数(你的视图)的简单映射。</p>
<p>映射可短可长，随便你。它可以引用其它的映射。而且，因为它是纯粹的Python 代码，它可以动态构造。</p>
<p>Django 还提供根据当前语言翻译URL 的一种方法。更多信息参见 <a class="reference internal" href="../i18n/translation.html#url-internationalization"><span class="std std-ref">国际化文档</span></a>。</p>
</div>
<div class="section" id="s-how-django-processes-a-request">
<span id="s-id1"></span><span id="how-django-processes-a-request"></span><span id="id1"></span><h2>Django 如何处理一个请求<a class="headerlink" href="#how-django-processes-a-request" title="永久链接至标题">¶</a></h2>
<p>当一个用户请求Django 站点的一个页面，下面是Django 系统决定执行哪个Python 代码使用的算法：</p>
<ol class="arabic simple">
<li>Django determines the root URLconf module to use. Ordinarily,
this is the value of the <a class="reference internal" href="../../ref/settings.html#std:setting-ROOT_URLCONF"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ROOT_URLCONF</span></code></a> setting, but if the incoming
<code class="docutils literal notranslate"><span class="pre">HttpRequest</span></code> object has a <a class="reference internal" href="../../ref/request-response.html#django.http.HttpRequest.urlconf" title="django.http.HttpRequest.urlconf"><code class="xref py py-attr docutils literal notranslate"><span class="pre">urlconf</span></code></a>
attribute (set by middleware), its value will be used in place of the
<a class="reference internal" href="../../ref/settings.html#std:setting-ROOT_URLCONF"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ROOT_URLCONF</span></code></a> setting.</li>
<li>Django loads that Python module and looks for the variable
<code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code>. This should be a Python list of <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.urls.path()</span></code></a>
and/or <a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.urls.re_path()</span></code></a> instances.</li>
<li>Django 依次匹配每个URL 模式，在与请求的URL 匹配的第一个模式停下来。</li>
<li>Once one of the URL patterns matches, Django imports and calls the given
view, which is a simple Python function (or a <a class="reference internal" href="../class-based-views/index.html"><span class="doc">class-based view</span></a>). The view gets passed the following
arguments:<ul>
<li>一个 <a class="reference internal" href="../../ref/request-response.html#django.http.HttpRequest" title="django.http.HttpRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">HttpRequest</span></code></a> 实例。</li>
<li>If the matched URL pattern returned no named groups, then the
matches from the regular expression are provided as positional arguments.</li>
<li>The keyword arguments are made up of any named parts matched by the
path expression, overridden by any arguments specified in the optional
<code class="docutils literal notranslate"><span class="pre">kwargs</span></code> argument to <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.urls.path()</span></code></a> or
<a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">django.urls.re_path()</span></code></a>.</li>
</ul>
</li>
<li>If no URL pattern matches, or if an exception is raised during any
point in this process, Django invokes an appropriate
error-handling view. See <a class="reference internal" href="#error-handling">Error handling</a> below.</li>
</ol>
</div>
<div class="section" id="s-example">
<span id="example"></span><h2>例如<a class="headerlink" href="#example" title="永久链接至标题">¶</a></h2>
<p>下面是一个简单的 URLconf:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/2003/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">special_case_2003</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/&lt;int:year&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">year_archive</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">month_archive</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">article_detail</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>注意：</p>
<ul class="simple">
<li>To capture a value from the URL, use angle brackets.</li>
<li>Captured values can optionally include a converter type. For example, use
<code class="docutils literal notranslate"><span class="pre">&lt;int:name&gt;</span></code> to capture an integer parameter. If a converter isn't included,
any string, excluding a <code class="docutils literal notranslate"><span class="pre">/</span></code> character, is matched.</li>
<li>There's no need to add a leading slash, because every URL has that. For
example, it's <code class="docutils literal notranslate"><span class="pre">articles</span></code>, not <code class="docutils literal notranslate"><span class="pre">/articles</span></code>.</li>
</ul>
<p>一些请求的例子：</p>
<ul class="simple">
<li>A request to <code class="docutils literal notranslate"><span class="pre">/articles/2005/03/</span></code> would match the third entry in the
list. Django would call the function
<code class="docutils literal notranslate"><span class="pre">views.month_archive(request,</span> <span class="pre">year=2005,</span> <span class="pre">month=3)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">/articles/2003/</span></code> would match the first pattern in the list, not the
second one, because the patterns are tested in order, and the first one
is the first test to pass. Feel free to exploit the ordering to insert
special cases like this. Here, Django would call the function
<code class="docutils literal notranslate"><span class="pre">views.special_case_2003(request)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">/articles/2003</span></code> would not match any of these patterns, because each
pattern requires that the URL end with a slash.</li>
<li><code class="docutils literal notranslate"><span class="pre">/articles/2003/03/building-a-django-site/</span></code> would match the final
pattern. Django would call the function
<code class="docutils literal notranslate"><span class="pre">views.article_detail(request,</span> <span class="pre">year=2003,</span> <span class="pre">month=3,</span> <span class="pre">slug=&quot;building-a-django-site&quot;)</span></code>.</li>
</ul>
</div>
<div class="section" id="s-path-converters">
<span id="path-converters"></span><h2>Path converters<a class="headerlink" href="#path-converters" title="永久链接至标题">¶</a></h2>
<p>The following path converters are available by default:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">str</span></code> - Matches any non-empty string, excluding the path separator, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>.
This is the default if a converter isn't included in the expression.</li>
<li><code class="docutils literal notranslate"><span class="pre">int</span></code> - Matches zero or any positive integer. Returns an <cite>int</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">slug</span></code> - Matches any slug string consisting of ASCII letters or numbers,
plus the hyphen and underscore characters. For example,
<code class="docutils literal notranslate"><span class="pre">building-your-1st-django-site</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">uuid</span></code> - Matches a formatted UUID. To prevent multiple URLs from mapping to
the same page, dashes must be included and letters must be lowercase. For
example, <code class="docutils literal notranslate"><span class="pre">075194d3-6885-417e-a8a8-6c931e272f00</span></code>. Returns a
<a class="reference external" href="https://docs.python.org/3/library/uuid.html#uuid.UUID" title="(在 Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">UUID</span></code></a> instance.</li>
<li><code class="docutils literal notranslate"><span class="pre">path</span></code> - Matches any non-empty string, including the path separator,
<code class="docutils literal notranslate"><span class="pre">'/'</span></code>. This allows you to match against a complete URL path rather than
just a segment of a URL path as with <code class="docutils literal notranslate"><span class="pre">str</span></code>.</li>
</ul>
</div>
<div class="section" id="s-registering-custom-path-converters">
<span id="s-id2"></span><span id="registering-custom-path-converters"></span><span id="id2"></span><h2>Registering custom path converters<a class="headerlink" href="#registering-custom-path-converters" title="永久链接至标题">¶</a></h2>
<p>For more complex matching requirements, you can define your own path converters.</p>
<p>A converter is a class that includes the following:</p>
<ul class="simple">
<li>A <code class="docutils literal notranslate"><span class="pre">regex</span></code> class attribute, as a string.</li>
<li>A <code class="docutils literal notranslate"><span class="pre">to_python(self,</span> <span class="pre">value)</span></code> method, which handles converting the matched
string into the type that should be passed to the view function. It should
raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if it can't convert the given value.</li>
<li>A <code class="docutils literal notranslate"><span class="pre">to_url(self,</span> <span class="pre">value)</span></code> method, which handles converting the Python type
into a string to be used in the URL.</li>
</ul>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FourDigitYearConverter</span><span class="p">:</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="s1">&#39;[0-9]</span><span class="si">{4}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%04d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span>
</pre></div>
</div>
<p>Register custom converter classes in your URLconf using
<a class="reference internal" href="../../ref/urls.html#django.urls.register_converter" title="django.urls.register_converter"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_converter()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">register_converter</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">converters</span><span class="p">,</span> <span class="n">views</span>

<span class="n">register_converter</span><span class="p">(</span><span class="n">converters</span><span class="o">.</span><span class="n">FourDigitYearConverter</span><span class="p">,</span> <span class="s1">&#39;yyyy&#39;</span><span class="p">)</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/2003/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">special_case_2003</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/&lt;yyyy:year&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">year_archive</span><span class="p">),</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="s-using-regular-expressions">
<span id="using-regular-expressions"></span><h2>Using regular expressions<a class="headerlink" href="#using-regular-expressions" title="永久链接至标题">¶</a></h2>
<p>If the paths and converters syntax isn't sufficient for defining your URL
patterns, you can also use regular expressions. To do so, use
<a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">re_path()</span></code></a> instead of <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a>.</p>
<p>In Python regular expressions, the syntax for named regular expression groups
is <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;pattern)</span></code>, where <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the group and
<code class="docutils literal notranslate"><span class="pre">pattern</span></code> is some pattern to match.</p>
<p>Here's the example URLconf from earlier, rewritten using regular expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">re_path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/2003/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">special_case_2003</span><span class="p">),</span>
    <span class="n">re_path</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^articles/(?P&lt;year&gt;[0-9]</span><span class="si">{4}</span><span class="s1">)/$&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">year_archive</span><span class="p">),</span>
    <span class="n">re_path</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^articles/(?P&lt;year&gt;[0-9]</span><span class="si">{4}</span><span class="s1">)/(?P&lt;month&gt;[0-9]</span><span class="si">{2}</span><span class="s1">)/$&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">month_archive</span><span class="p">),</span>
    <span class="n">re_path</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^articles/(?P&lt;year&gt;[0-9]</span><span class="si">{4}</span><span class="s1">)/(?P&lt;month&gt;[0-9]</span><span class="si">{2}</span><span class="s1">)/(?P&lt;slug&gt;[\w-]+)/$&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">article_detail</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This accomplishes roughly the same thing as the previous example, except:</p>
<ul class="simple">
<li>The exact URLs that will match are slightly more constrained. For example,
the year 10000 will no longer match since the year integers are constrained
to be exactly four digits long.</li>
<li>Each captured argument is sent to the view as a string, regardless of what
sort of match the regular expression makes.</li>
</ul>
<p>When switching from using <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a> to
<a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">re_path()</span></code></a> or vice versa, it's particularly important to be
aware that the type of the view arguments may change, and so you may need to
adapt your views.</p>
<div class="section" id="s-using-unnamed-regular-expression-groups">
<span id="using-unnamed-regular-expression-groups"></span><h3>Using unnamed regular expression groups<a class="headerlink" href="#using-unnamed-regular-expression-groups" title="永久链接至标题">¶</a></h3>
<p>As well as the named group syntax, e.g. <code class="docutils literal notranslate"><span class="pre">(?P&lt;year&gt;[0-9]{4})</span></code>, you can
also use the shorter unnamed group, e.g. <code class="docutils literal notranslate"><span class="pre">([0-9]{4})</span></code>.</p>
<p>This usage isn't particularly recommended as it makes it easier to accidentally
introduce errors between the intended meaning of a match and the arguments
of the view.</p>
<p>In either case, using only one style within a given regex is recommended. When
both styles are mixed, any unnamed groups are ignored and only named groups are
passed to the view function.</p>
</div>
<div class="section" id="s-nested-arguments">
<span id="nested-arguments"></span><h3>Nested arguments<a class="headerlink" href="#nested-arguments" title="永久链接至标题">¶</a></h3>
<p>Regular expressions allow nested arguments, and Django will resolve them and
pass them to the view. When reversing, Django will try to fill in all outer
captured arguments, ignoring any nested captured arguments. Consider the
following URL patterns which optionally take a page argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">re_path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">re_path</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^blog/(page-(\d+)/)?$&#39;</span><span class="p">,</span> <span class="n">blog_articles</span><span class="p">),</span>                  <span class="c1"># bad</span>
    <span class="n">re_path</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^comments/(?:page-(?P&lt;page_number&gt;\d+)/)?$&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="p">),</span>  <span class="c1"># good</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Both patterns use nested arguments and will resolve: for example,
<code class="docutils literal notranslate"><span class="pre">blog/page-2/</span></code> will result in a match to <code class="docutils literal notranslate"><span class="pre">blog_articles</span></code> with two
positional arguments: <code class="docutils literal notranslate"><span class="pre">page-2/</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>. The second pattern for
<code class="docutils literal notranslate"><span class="pre">comments</span></code> will match <code class="docutils literal notranslate"><span class="pre">comments/page-2/</span></code> with keyword argument
<code class="docutils literal notranslate"><span class="pre">page_number</span></code> set to 2. The outer argument in this case is a non-capturing
argument <code class="docutils literal notranslate"><span class="pre">(?:...)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">blog_articles</span></code> view needs the outermost captured argument to be reversed,
<code class="docutils literal notranslate"><span class="pre">page-2/</span></code> or no arguments in this case, while <code class="docutils literal notranslate"><span class="pre">comments</span></code> can be reversed
with either no arguments or a value for <code class="docutils literal notranslate"><span class="pre">page_number</span></code>.</p>
<p>Nested captured arguments create a strong coupling between the view arguments
and the URL as illustrated by <code class="docutils literal notranslate"><span class="pre">blog_articles</span></code>: the view receives part of the
URL (<code class="docutils literal notranslate"><span class="pre">page-2/</span></code>) instead of only the value the view is interested in. This
coupling is even more pronounced when reversing, since to reverse the view we
need to pass the piece of URL instead of the page number.</p>
<p>As a rule of thumb, only capture the values the view needs to work with and
use non-capturing arguments when the regular expression needs an argument but
the view ignores it.</p>
</div>
</div>
<div class="section" id="s-what-the-urlconf-searches-against">
<span id="what-the-urlconf-searches-against"></span><h2>URLconf 在什么上查找<a class="headerlink" href="#what-the-urlconf-searches-against" title="永久链接至标题">¶</a></h2>
<p>请求的URL被看做是一个普通的Python 字符串， URLconf在其上查找并匹配。进行匹配时将不包括GET或POST请求方式的参数以及域名。</p>
<p>例如，  <code class="docutils literal notranslate"><span class="pre">https://www.example.com/myapp/</span></code> 请求中，URLconf 将查找 <code class="docutils literal notranslate"><span class="pre">myapp/</span></code></p>
<p>在 <code class="docutils literal notranslate"><span class="pre">https://www.example.com/myapp/?page=3</span></code> 请求中，URLconf 仍将查找 <code class="docutils literal notranslate"><span class="pre">myapp/</span></code> 。</p>
<p>URLconf 不检查使用了哪种请求方法。换句话讲，所有的请求方法 —— 即，对同一个URL的无论是 <code class="docutils literal notranslate"><span class="pre">POST请求</span></code> 、 <code class="docutils literal notranslate"><span class="pre">GET请求</span></code> 、或 <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> 请求方法等等 —— 都将路由到相同的函数。</p>
</div>
<div class="section" id="s-specifying-defaults-for-view-arguments">
<span id="specifying-defaults-for-view-arguments"></span><h2>指定视图参数的默认值<a class="headerlink" href="#specifying-defaults-for-view-arguments" title="永久链接至标题">¶</a></h2>
<p>有一个方便的小技巧是指定视图参数的默认值。 下面是一个URLconf 和视图的示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># URLconf</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;blog/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">page</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;blog/page&lt;int:num&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">page</span><span class="p">),</span>
<span class="p">]</span>

<span class="c1"># View (in blog/views.py)</span>
<span class="k">def</span> <span class="nf">page</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Output the appropriate page of blog entries, according to num.</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>In the above example, both URL patterns point to the same view --
<code class="docutils literal notranslate"><span class="pre">views.page</span></code> -- but the first pattern doesn't capture anything from the
URL. If the first pattern matches, the <code class="docutils literal notranslate"><span class="pre">page()</span></code> function will use its
default argument for <code class="docutils literal notranslate"><span class="pre">num</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>. If the second pattern matches,
<code class="docutils literal notranslate"><span class="pre">page()</span></code> will use whatever <code class="docutils literal notranslate"><span class="pre">num</span></code> value was captured.</p>
</div>
<div class="section" id="s-performance">
<span id="performance"></span><h2>性能<a class="headerlink" href="#performance" title="永久链接至标题">¶</a></h2>
<p>Each regular expression in a <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> is compiled the first time it's
accessed. This makes the system blazingly fast.</p>
</div>
<div class="section" id="s-syntax-of-the-urlpatterns-variable">
<span id="syntax-of-the-urlpatterns-variable"></span><h2><code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> 变量的语法<a class="headerlink" href="#syntax-of-the-urlpatterns-variable" title="永久链接至标题">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> should be a Python list of <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a> and/or
<a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">re_path()</span></code></a> instances.</p>
</div>
<div class="section" id="s-error-handling">
<span id="error-handling"></span><h2>错误处理<a class="headerlink" href="#error-handling" title="永久链接至标题">¶</a></h2>
<p>When Django can't find a match for the requested URL, or when an exception is
raised, Django invokes an error-handling view.</p>
<p>这些情况发生时使用的视图通过4个变量指定。它们的默认值应该满足大部分项目，但是通过赋值给它们以进一步的自定义也是可以的。</p>
<p>完整的细节请参见 <a class="reference internal" href="views.html#customizing-error-views"><span class="std std-ref">自定义错误视图</span></a>  。</p>
<p>这些值得在你的根URLconf 中设置。在其它URLconf 中设置这些变量将不会生效果。</p>
<p>它们的值必须是可调用的或者是表示视图的Python 完整导入路径的字符串，可以方便地调用它们来处理错误情况。</p>
<p>这些值是：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">handler400</span></code> -- 查看 <a class="reference internal" href="../../ref/urls.html#django.conf.urls.handler400" title="django.conf.urls.handler400"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.conf.urls.handler400</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">handler403</span></code> -- 查看 <a class="reference internal" href="../../ref/urls.html#django.conf.urls.handler403" title="django.conf.urls.handler403"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.conf.urls.handler403</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">handler404</span></code> -- 查看 <a class="reference internal" href="../../ref/urls.html#django.conf.urls.handler404" title="django.conf.urls.handler404"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.conf.urls.handler404</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">handler500</span></code> -- 查看 <a class="reference internal" href="../../ref/urls.html#django.conf.urls.handler500" title="django.conf.urls.handler500"><code class="xref py py-data docutils literal notranslate"><span class="pre">django.conf.urls.handler500</span></code></a>.</li>
</ul>
</div>
<div class="section" id="s-including-other-urlconfs">
<span id="s-id3"></span><span id="including-other-urlconfs"></span><span id="id3"></span><h2>包含其它的URLconfs<a class="headerlink" href="#including-other-urlconfs" title="永久链接至标题">¶</a></h2>
<p>在任何时候，你的 <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> 都可以 &quot;include&quot; 其它URLconf 模块。这实际上将一部分URL 放置于其它URL 下面。</p>
<p>例如，下面是URLconf  <a class="reference external" href="https://www.djangoproject.com/">Django website</a> 自己的URLconf 中一个片段。它包含许多其它URLconf：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># ... snip ...</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;community/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;aggregator.urls&#39;</span><span class="p">)),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;contact/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;contact.urls&#39;</span><span class="p">)),</span>
    <span class="c1"># ... snip ...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Whenever Django encounters <a class="reference internal" href="../../ref/urls.html#django.urls.include" title="django.urls.include"><code class="xref py py-func docutils literal notranslate"><span class="pre">include()</span></code></a>, it chops off
whatever part of the URL matched up to that point and sends the remaining
string to the included URLconf for further processing.</p>
<p>Another possibility is to include additional URL patterns by using a list of
<a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a> instances. For example, consider this URLconf:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">apps.main</span> <span class="k">import</span> <span class="n">views</span> <span class="k">as</span> <span class="n">main_views</span>
<span class="kn">from</span> <span class="nn">credit</span> <span class="k">import</span> <span class="n">views</span> <span class="k">as</span> <span class="n">credit_views</span>

<span class="n">extra_patterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;reports/&#39;</span><span class="p">,</span> <span class="n">credit_views</span><span class="o">.</span><span class="n">report</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;reports/&lt;int:id&gt;/&#39;</span><span class="p">,</span> <span class="n">credit_views</span><span class="o">.</span><span class="n">report</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;charge/&#39;</span><span class="p">,</span> <span class="n">credit_views</span><span class="o">.</span><span class="n">charge</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">main_views</span><span class="o">.</span><span class="n">homepage</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;help/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;apps.help.urls&#39;</span><span class="p">)),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;credit/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="n">extra_patterns</span><span class="p">)),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>在这个例子中， <code class="docutils literal notranslate"><span class="pre">/credit/reports/</span></code>  URL将被 <code class="docutils literal notranslate"><span class="pre">credit.views.report()</span></code> 这个Django 视图处理。</p>
<p>这种方法可以用来去除URLconf 中的冗余，其中某个模式前缀被重复使用。例如，考虑这个URLconf:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;page_slug&gt;-&lt;page_id&gt;/history/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">history</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;page_slug&gt;-&lt;page_id&gt;/edit/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">edit</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;page_slug&gt;-&lt;page_id&gt;/discuss/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">discuss</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;page_slug&gt;-&lt;page_id&gt;/permissions/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">permissions</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>我们可以改进它，通过只声明共同的路径前缀一次并将后面的部分分组:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;page_slug&gt;-&lt;page_id&gt;/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">([</span>
        <span class="n">path</span><span class="p">(</span><span class="s1">&#39;history/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">history</span><span class="p">),</span>
        <span class="n">path</span><span class="p">(</span><span class="s1">&#39;edit/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">edit</span><span class="p">),</span>
        <span class="n">path</span><span class="p">(</span><span class="s1">&#39;discuss/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">discuss</span><span class="p">),</span>
        <span class="n">path</span><span class="p">(</span><span class="s1">&#39;permissions/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">permissions</span><span class="p">),</span>
    <span class="p">])),</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="section" id="s-captured-parameters">
<span id="captured-parameters"></span><h3>捕获的参数<a class="headerlink" href="#captured-parameters" title="永久链接至标题">¶</a></h3>
<p>被包含的URLconf 会收到来自父URLconf 捕获的任何参数，所以下面的例子是合法的:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># In settings/urls/main.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;username&gt;/blog/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;foo.urls.blog&#39;</span><span class="p">)),</span>
<span class="p">]</span>

<span class="c1"># In foo/urls/blog.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">blog</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;archive/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">blog</span><span class="o">.</span><span class="n">archive</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>在上面的例子中，捕获的 <code class="docutils literal notranslate"><span class="pre">&quot;username&quot;</span></code> 变量将被如期传递给include()指向的URLconf。</p>
</div>
</div>
<div class="section" id="s-passing-extra-options-to-view-functions">
<span id="s-views-extra-options"></span><span id="passing-extra-options-to-view-functions"></span><span id="views-extra-options"></span><h2>Passing extra options to view functions<a class="headerlink" href="#passing-extra-options-to-view-functions" title="永久链接至标题">¶</a></h2>
<p>URLconfs have a hook that lets you pass extra arguments to your view functions,
as a Python dictionary.</p>
<p>The <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a> function can take an optional third argument
which should be a dictionary of extra keyword arguments to pass to the view
function.</p>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;blog/&lt;int:year&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">year_archive</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>In this example, for a request to <code class="docutils literal notranslate"><span class="pre">/blog/2005/</span></code>, Django will call
<code class="docutils literal notranslate"><span class="pre">views.year_archive(request,</span> <span class="pre">year=2005,</span> <span class="pre">foo='bar')</span></code>.</p>
<p>This technique is used in the
<a class="reference internal" href="../../ref/contrib/syndication.html"><span class="doc">syndication framework</span></a> to pass metadata and
options to views.</p>
<div class="admonition-dealing-with-conflicts admonition">
<p class="first admonition-title">Dealing with conflicts</p>
<p class="last">It's possible to have a URL pattern which captures named keyword arguments,
and also passes arguments with the same names in its dictionary of extra
arguments. When this happens, the arguments in the dictionary will be used
instead of the arguments captured in the URL.</p>
</div>
<div class="section" id="s-passing-extra-options-to-include">
<span id="passing-extra-options-to-include"></span><h3>Passing extra options to <code class="docutils literal notranslate"><span class="pre">include()</span></code><a class="headerlink" href="#passing-extra-options-to-include" title="永久链接至标题">¶</a></h3>
<p>Similarly, you can pass extra options to <a class="reference internal" href="../../ref/urls.html#django.urls.include" title="django.urls.include"><code class="xref py py-func docutils literal notranslate"><span class="pre">include()</span></code></a> and
each line in the included URLconf will be passed the extra options.</p>
<p>For example, these two URLconf sets are functionally identical:</p>
<p>Set one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># main.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;blog/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;blog_id&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}),</span>
<span class="p">]</span>

<span class="c1"># inner.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">mysite</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;archive/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">archive</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;about/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">about</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Set two:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># main.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">mysite</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;blog/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">)),</span>
<span class="p">]</span>

<span class="c1"># inner.py</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;archive/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">archive</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;blog_id&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;about/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">about</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;blog_id&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Note that extra options will <em>always</em> be passed to <em>every</em> line in the included
URLconf, regardless of whether the line's view actually accepts those options
as valid. For this reason, this technique is only useful if you're certain that
every view in the included URLconf accepts the extra options you're passing.</p>
</div>
</div>
<div class="section" id="s-reverse-resolution-of-urls">
<span id="reverse-resolution-of-urls"></span><h2>Reverse resolution of URLs<a class="headerlink" href="#reverse-resolution-of-urls" title="永久链接至标题">¶</a></h2>
<p>A common need when working on a Django project is the possibility to obtain URLs
in their final forms either for embedding in generated content (views and assets
URLs, URLs shown to the user, etc.) or for handling of the navigation flow on
the server side (redirections, etc.)</p>
<p>It is strongly desirable to avoid hard-coding these URLs (a laborious,
non-scalable and error-prone strategy). Equally dangerous is devising ad-hoc
mechanisms to generate URLs that are parallel to the design described by the
URLconf, which can result in the production of URLs that become stale over time.</p>
<p>In other words, what's needed is a DRY mechanism. Among other advantages it
would allow evolution of the URL design without having to go over all the
project source code to search and replace outdated URLs.</p>
<p>The primary piece of information we have available to get a URL is an
identification (e.g. the name) of the view in charge of handling it. Other
pieces of information that necessarily must participate in the lookup of the
right URL are the types (positional, keyword) and values of the view arguments.</p>
<p>Django provides a solution such that the URL mapper is the only repository of
the URL design. You feed it with your URLconf and then it can be used in both
directions:</p>
<ul class="simple">
<li>Starting with a URL requested by the user/browser, it calls the right Django
view providing any arguments it might need with their values as extracted from
the URL.</li>
<li>Starting with the identification of the corresponding Django view plus the
values of arguments that would be passed to it, obtain the associated URL.</li>
</ul>
<p>The first one is the usage we've been discussing in the previous sections. The
second one is what is known as <em>reverse resolution of URLs</em>, <em>reverse URL
matching</em>, <em>reverse URL lookup</em>, or simply <em>URL reversing</em>.</p>
<p>Django provides tools for performing URL reversing that match the different
layers where URLs are needed:</p>
<ul class="simple">
<li>In templates: Using the <a class="reference internal" href="../../ref/templates/builtins.html#std:templatetag-url"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">url</span></code></a> template tag.</li>
<li>In Python code: Using the <a class="reference internal" href="../../ref/urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a> function.</li>
<li>In higher level code related to handling of URLs of Django model instances:
The <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.get_absolute_url" title="django.db.models.Model.get_absolute_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_absolute_url()</span></code></a> method.</li>
</ul>
<div class="section" id="s-examples">
<span id="examples"></span><h3>示例<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h3>
<p>Consider again this URLconf entry:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1">#...</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;articles/&lt;int:year&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">year_archive</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;news-year-archive&#39;</span><span class="p">),</span>
    <span class="c1">#...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>According to this design, the URL for the archive corresponding to year <em>nnnn</em>
is <code class="docutils literal notranslate"><span class="pre">/articles/&lt;nnnn&gt;/</span></code>.</p>
<p>You can obtain these in template code by using:</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;</span><span class="cp">{%</span> <span class="k">url</span> <span class="s1">&#39;news-year-archive&#39;</span> <span class="m">2012</span> <span class="cp">%}</span><span class="s">&quot;</span><span class="p">&gt;</span>2012 Archive<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
<span class="c">{# Or with the year in a template context variable: #}</span>
<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">yearvar</span> <span class="k">in</span> <span class="nv">year_list</span> <span class="cp">%}</span>
<span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;</span><span class="cp">{%</span> <span class="k">url</span> <span class="s1">&#39;news-year-archive&#39;</span> <span class="nv">yearvar</span> <span class="cp">%}</span><span class="s">&quot;</span><span class="p">&gt;</span><span class="cp">{{</span> <span class="nv">yearvar</span> <span class="cp">}}</span> Archive<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Or in Python code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.http</span> <span class="k">import</span> <span class="n">HttpResponseRedirect</span>
<span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">reverse</span>

<span class="k">def</span> <span class="nf">redirect_to_year</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">year</span> <span class="o">=</span> <span class="mi">2006</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">HttpResponseRedirect</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;news-year-archive&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">year</span><span class="p">,)))</span>
</pre></div>
</div>
<p>If, for some reason, it was decided that the URLs where content for yearly
article archives are published at should be changed then you would only need to
change the entry in the URLconf.</p>
<p>In some scenarios where views are of a generic nature, a many-to-one
relationship might exist between URLs and views. For these cases the view name
isn't a good enough identifier for it when comes the time of reversing
URLs. Read the next section to know about the solution Django provides for this.</p>
</div>
</div>
<div class="section" id="s-naming-url-patterns">
<span id="s-id4"></span><span id="naming-url-patterns"></span><span id="id4"></span><h2>Naming URL patterns<a class="headerlink" href="#naming-url-patterns" title="永久链接至标题">¶</a></h2>
<p>In order to perform URL reversing, you'll need to use <strong>named URL patterns</strong>
as done in the examples above. The string used for the URL name can contain any
characters you like. You are not restricted to valid Python names.</p>
<p>When naming URL patterns, choose names that are unlikely to clash with other
applications' choice of names. If you call your URL pattern <code class="docutils literal notranslate"><span class="pre">comment</span></code>
and another application does the same thing, the URL that
<a class="reference internal" href="../../ref/urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a> finds depends on whichever pattern is last in
your project's <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> list.</p>
<p>Putting a prefix on your URL names, perhaps derived from the application
name (such as <code class="docutils literal notranslate"><span class="pre">myapp-comment</span></code> instead of <code class="docutils literal notranslate"><span class="pre">comment</span></code>), decreases the chance
of collision.</p>
<p>You can deliberately choose the <em>same URL name</em> as another application if you
want to override a view. For example, a common use case is to override the
<a class="reference internal" href="../auth/default.html#django.contrib.auth.views.LoginView" title="django.contrib.auth.views.LoginView"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoginView</span></code></a>. Parts of Django and most
third-party apps assume that this view has a URL pattern with the name
<code class="docutils literal notranslate"><span class="pre">login</span></code>. If you have a custom login view and give its URL the name <code class="docutils literal notranslate"><span class="pre">login</span></code>,
<a class="reference internal" href="../../ref/urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a> will find your custom view as long as it's in
<code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> after <code class="docutils literal notranslate"><span class="pre">django.contrib.auth.urls</span></code> is included (if that's
included at all).</p>
<p>You may also use the same name for multiple URL patterns if they differ in
their arguments. In addition to the URL name, <a class="reference internal" href="../../ref/urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a>
matches the number of arguments and the names of the keyword arguments.</p>
</div>
<div class="section" id="s-url-namespaces">
<span id="s-topics-http-defining-url-namespaces"></span><span id="url-namespaces"></span><span id="topics-http-defining-url-namespaces"></span><h2>URL namespaces<a class="headerlink" href="#url-namespaces" title="永久链接至标题">¶</a></h2>
<div class="section" id="s-introduction">
<span id="introduction"></span><h3>介绍<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h3>
<p>URL namespaces allow you to uniquely reverse <a class="reference internal" href="#naming-url-patterns"><span class="std std-ref">named URL patterns</span></a> even if different applications use the same URL names.
It's a good practice for third-party apps to always use namespaced URLs (as we
did in the tutorial). Similarly, it also allows you to reverse URLs if multiple
instances of an application are deployed. In other words, since multiple
instances of a single application will share named URLs, namespaces provide a
way to tell these named URLs apart.</p>
<p>Django applications that make proper use of URL namespacing can be deployed more
than once for a particular site. For example <a class="reference internal" href="../../ref/contrib/admin/index.html#module-django.contrib.admin" title="django.contrib.admin: Django's admin site."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admin</span></code></a> has an
<a class="reference internal" href="../../ref/contrib/admin/index.html#django.contrib.admin.AdminSite" title="django.contrib.admin.AdminSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdminSite</span></code></a> class which allows you to easily
<a class="reference internal" href="../../ref/contrib/admin/index.html#multiple-admin-sites"><span class="std std-ref">deploy more than one instance of the admin</span></a>.
In a later example, we'll discuss the idea of deploying the polls application
from the tutorial in two different locations so we can serve the same
functionality to two different audiences (authors and publishers).</p>
<p>A URL namespace comes in two parts, both of which are strings:</p>
<dl class="glossary docutils">
<dt id="term-application-namespace">application namespace</dt>
<dd>This describes the name of the application that is being deployed. Every
instance of a single application will have the same application namespace.
For example, Django's admin application has the somewhat predictable
application namespace of <code class="docutils literal notranslate"><span class="pre">'admin'</span></code>.</dd>
<dt id="term-instance-namespace">instance namespace</dt>
<dd>This identifies a specific instance of an application. Instance namespaces
should be unique across your entire project. However, an instance namespace
can be the same as the application namespace. This is used to specify a
default instance of an application. For example, the default Django admin
instance has an instance namespace of <code class="docutils literal notranslate"><span class="pre">'admin'</span></code>.</dd>
</dl>
<p>Namespaced URLs are specified using the <code class="docutils literal notranslate"><span class="pre">':'</span></code> operator. For example, the main
index page of the admin application is referenced using <code class="docutils literal notranslate"><span class="pre">'admin:index'</span></code>. This
indicates a namespace of <code class="docutils literal notranslate"><span class="pre">'admin'</span></code>, and a named URL of <code class="docutils literal notranslate"><span class="pre">'index'</span></code>.</p>
<p>Namespaces can also be nested. The named URL <code class="docutils literal notranslate"><span class="pre">'sports:polls:index'</span></code> would
look for a pattern named <code class="docutils literal notranslate"><span class="pre">'index'</span></code> in the namespace <code class="docutils literal notranslate"><span class="pre">'polls'</span></code> that is itself
defined within the top-level namespace <code class="docutils literal notranslate"><span class="pre">'sports'</span></code>.</p>
</div>
<div class="section" id="s-reversing-namespaced-urls">
<span id="s-topics-http-reversing-url-namespaces"></span><span id="reversing-namespaced-urls"></span><span id="topics-http-reversing-url-namespaces"></span><h3>Reversing namespaced URLs<a class="headerlink" href="#reversing-namespaced-urls" title="永久链接至标题">¶</a></h3>
<p>When given a namespaced URL (e.g. <code class="docutils literal notranslate"><span class="pre">'polls:index'</span></code>) to resolve, Django splits
the fully qualified name into parts and then tries the following lookup:</p>
<ol class="arabic">
<li><p class="first">First, Django looks for a matching <a class="reference internal" href="#term-application-namespace"><span class="xref std std-term">application namespace</span></a> (in this
example, <code class="docutils literal notranslate"><span class="pre">'polls'</span></code>). This will yield a list of instances of that
application.</p>
</li>
<li><p class="first">If there is a current application defined, Django finds and returns the URL
resolver for that instance. The current application can be specified with
the <code class="docutils literal notranslate"><span class="pre">current_app</span></code> argument to the <a class="reference internal" href="../../ref/urlresolvers.html#django.urls.reverse" title="django.urls.reverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">reverse()</span></code></a>
function.</p>
<p>The <a class="reference internal" href="../../ref/templates/builtins.html#std:templatetag-url"><code class="xref std std-ttag docutils literal notranslate"><span class="pre">url</span></code></a> template tag uses the namespace of the currently resolved
view as the current application in a
<a class="reference internal" href="../../ref/templates/api.html#django.template.RequestContext" title="django.template.RequestContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">RequestContext</span></code></a>. You can override this default by
setting the current application on the <a class="reference internal" href="../../ref/request-response.html#django.http.HttpRequest.current_app" title="django.http.HttpRequest.current_app"><code class="xref py py-attr docutils literal notranslate"><span class="pre">request.current_app</span></code></a> attribute.</p>
</li>
<li><p class="first">If there is no current application, Django looks for a default
application instance. The default application instance is the instance
that has an <a class="reference internal" href="#term-instance-namespace"><span class="xref std std-term">instance namespace</span></a> matching the <a class="reference internal" href="#term-application-namespace"><span class="xref std std-term">application
namespace</span></a> (in this example, an instance of <code class="docutils literal notranslate"><span class="pre">polls</span></code> called <code class="docutils literal notranslate"><span class="pre">'polls'</span></code>).</p>
</li>
<li><p class="first">If there is no default application instance, Django will pick the last
deployed instance of the application, whatever its instance name may be.</p>
</li>
<li><p class="first">If the provided namespace doesn't match an <a class="reference internal" href="#term-application-namespace"><span class="xref std std-term">application namespace</span></a> in
step 1, Django will attempt a direct lookup of the namespace as an
<a class="reference internal" href="#term-instance-namespace"><span class="xref std std-term">instance namespace</span></a>.</p>
</li>
</ol>
<p>If there are nested namespaces, these steps are repeated for each part of the
namespace until only the view name is unresolved. The view name will then be
resolved into a URL in the namespace that has been found.</p>
<div class="section" id="s-id5">
<span id="id5"></span><h4>例如<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>To show this resolution strategy in action, consider an example of two instances
of the <code class="docutils literal notranslate"><span class="pre">polls</span></code> application from the tutorial: one called <code class="docutils literal notranslate"><span class="pre">'author-polls'</span></code>
and one called <code class="docutils literal notranslate"><span class="pre">'publisher-polls'</span></code>. Assume we have enhanced that application
so that it takes the instance namespace into consideration when creating and
displaying polls.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">urls.py</span><a class="headerlink" href="#id6" title="永久链接至代码">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="kn">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;author-polls/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;polls.urls&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;author-polls&#39;</span><span class="p">)),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;publisher-polls/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;polls.urls&#39;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;publisher-polls&#39;</span><span class="p">)),</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">polls/urls.py</span><a class="headerlink" href="#id7" title="永久链接至代码">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="kn">import</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">views</span>

<span class="n">app_name</span> <span class="o">=</span> <span class="s1">&#39;polls&#39;</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">IndexView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;int:pk&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">DetailView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;detail&#39;</span><span class="p">),</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<p>Using this setup, the following lookups are possible:</p>
<ul>
<li><p class="first">If one of the instances is current - say, if we were rendering the detail page
in the instance <code class="docutils literal notranslate"><span class="pre">'author-polls'</span></code> - <code class="docutils literal notranslate"><span class="pre">'polls:index'</span></code> will resolve to the
index page of the <code class="docutils literal notranslate"><span class="pre">'author-polls'</span></code> instance; i.e. both of the following will
result in <code class="docutils literal notranslate"><span class="pre">&quot;/author-polls/&quot;</span></code>.</p>
<p>In the method of a class-based view:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;polls:index&#39;</span><span class="p">,</span> <span class="n">current_app</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">resolver_match</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>
</pre></div>
</div>
<p>and in the template:</p>
<div class="highlight-html+django notranslate"><div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">url</span> <span class="s1">&#39;polls:index&#39;</span> <span class="cp">%}</span>
</pre></div>
</div>
</li>
<li><p class="first">If there is no current instance - say, if we were rendering a page
somewhere else on the site - <code class="docutils literal notranslate"><span class="pre">'polls:index'</span></code> will resolve to the last
registered instance of <code class="docutils literal notranslate"><span class="pre">polls</span></code>. Since there is no default instance
(instance namespace of <code class="docutils literal notranslate"><span class="pre">'polls'</span></code>), the last instance of <code class="docutils literal notranslate"><span class="pre">polls</span></code> that is
registered will be used. This would be <code class="docutils literal notranslate"><span class="pre">'publisher-polls'</span></code> since it's
declared last in the <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">'author-polls:index'</span></code> will always resolve to the index page of the instance
<code class="docutils literal notranslate"><span class="pre">'author-polls'</span></code> (and likewise for <code class="docutils literal notranslate"><span class="pre">'publisher-polls'</span></code>) .</p>
</li>
</ul>
<p>If there were also a default instance - i.e., an instance named <code class="docutils literal notranslate"><span class="pre">'polls'</span></code> -
the only change from above would be in the case where there is no current
instance (the second item in the list above). In this case <code class="docutils literal notranslate"><span class="pre">'polls:index'</span></code>
would resolve to the index page of the default instance instead of the instance
declared last in <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code>.</p>
</div>
</div>
<div class="section" id="s-url-namespaces-and-included-urlconfs">
<span id="s-namespaces-and-include"></span><span id="url-namespaces-and-included-urlconfs"></span><span id="namespaces-and-include"></span><h3>URL namespaces and included URLconfs<a class="headerlink" href="#url-namespaces-and-included-urlconfs" title="永久链接至标题">¶</a></h3>
<p>Application namespaces of included URLconfs can be specified in two ways.</p>
<p>Firstly, you can set an <code class="docutils literal notranslate"><span class="pre">app_name</span></code> attribute in the included URLconf module,
at the same level as the <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> attribute. You have to pass the actual
module, or a string reference to the module, to <a class="reference internal" href="../../ref/urls.html#django.urls.include" title="django.urls.include"><code class="xref py py-func docutils literal notranslate"><span class="pre">include()</span></code></a>,
not the list of <code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> itself.</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">polls/urls.py</span><a class="headerlink" href="#id8" title="永久链接至代码">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="kn">import</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">views</span>

<span class="n">app_name</span> <span class="o">=</span> <span class="s1">&#39;polls&#39;</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">IndexView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;int:pk&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">DetailView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;detail&#39;</span><span class="p">),</span>
    <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">urls.py</span><a class="headerlink" href="#id9" title="永久链接至代码">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="kn">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;polls/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="s1">&#39;polls.urls&#39;</span><span class="p">)),</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<p>The URLs defined in <code class="docutils literal notranslate"><span class="pre">polls.urls</span></code> will have an application namespace <code class="docutils literal notranslate"><span class="pre">polls</span></code>.</p>
<p>Secondly, you can include an object that contains embedded namespace data. If
you <code class="docutils literal notranslate"><span class="pre">include()</span></code> a list of <a class="reference internal" href="../../ref/urls.html#django.urls.path" title="django.urls.path"><code class="xref py py-func docutils literal notranslate"><span class="pre">path()</span></code></a> or
<a class="reference internal" href="../../ref/urls.html#django.urls.re_path" title="django.urls.re_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">re_path()</span></code></a> instances, the URLs contained in that object
will be added to the global namespace. However, you can also <code class="docutils literal notranslate"><span class="pre">include()</span></code> a
2-tuple containing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;</span><span class="nb">list</span> <span class="n">of</span> <span class="n">path</span><span class="p">()</span><span class="o">/</span><span class="n">re_path</span><span class="p">()</span> <span class="n">instances</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">application</span> <span class="n">namespace</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.urls</span> <span class="k">import</span> <span class="n">include</span><span class="p">,</span> <span class="n">path</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">views</span>

<span class="n">polls_patterns</span> <span class="o">=</span> <span class="p">([</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">IndexView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">),</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;&lt;int:pk&gt;/&#39;</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">DetailView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;detail&#39;</span><span class="p">),</span>
<span class="p">],</span> <span class="s1">&#39;polls&#39;</span><span class="p">)</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">path</span><span class="p">(</span><span class="s1">&#39;polls/&#39;</span><span class="p">,</span> <span class="n">include</span><span class="p">(</span><span class="n">polls_patterns</span><span class="p">)),</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This will include the nominated URL patterns into the given application
namespace.</p>
<p>The instance namespace can be specified using the <code class="docutils literal notranslate"><span class="pre">namespace</span></code> argument to
<a class="reference internal" href="../../ref/urls.html#django.urls.include" title="django.urls.include"><code class="xref py py-func docutils literal notranslate"><span class="pre">include()</span></code></a>. If the instance namespace is not specified,
it will default to the included URLconf's application namespace. This means
it will also be the default instance for that namespace.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">URL调度器</a><ul>
<li><a class="reference internal" href="#overview">概况</a></li>
<li><a class="reference internal" href="#how-django-processes-a-request">Django 如何处理一个请求</a></li>
<li><a class="reference internal" href="#example">例如</a></li>
<li><a class="reference internal" href="#path-converters">Path converters</a></li>
<li><a class="reference internal" href="#registering-custom-path-converters">Registering custom path converters</a></li>
<li><a class="reference internal" href="#using-regular-expressions">Using regular expressions</a><ul>
<li><a class="reference internal" href="#using-unnamed-regular-expression-groups">Using unnamed regular expression groups</a></li>
<li><a class="reference internal" href="#nested-arguments">Nested arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#what-the-urlconf-searches-against">URLconf 在什么上查找</a></li>
<li><a class="reference internal" href="#specifying-defaults-for-view-arguments">指定视图参数的默认值</a></li>
<li><a class="reference internal" href="#performance">性能</a></li>
<li><a class="reference internal" href="#syntax-of-the-urlpatterns-variable"><code class="docutils literal notranslate"><span class="pre">urlpatterns</span></code> 变量的语法</a></li>
<li><a class="reference internal" href="#error-handling">错误处理</a></li>
<li><a class="reference internal" href="#including-other-urlconfs">包含其它的URLconfs</a><ul>
<li><a class="reference internal" href="#captured-parameters">捕获的参数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#passing-extra-options-to-view-functions">Passing extra options to view functions</a><ul>
<li><a class="reference internal" href="#passing-extra-options-to-include">Passing extra options to <code class="docutils literal notranslate"><span class="pre">include()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#reverse-resolution-of-urls">Reverse resolution of URLs</a><ul>
<li><a class="reference internal" href="#examples">示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#naming-url-patterns">Naming URL patterns</a></li>
<li><a class="reference internal" href="#url-namespaces">URL namespaces</a><ul>
<li><a class="reference internal" href="#introduction">介绍</a></li>
<li><a class="reference internal" href="#reversing-namespaced-urls">Reversing namespaced URLs</a><ul>
<li><a class="reference internal" href="#id5">例如</a></li>
</ul>
</li>
<li><a class="reference internal" href="#url-namespaces-and-included-urlconfs">URL namespaces and included URLconfs</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="index.html"
                        title="上一章">处理 HTTP 请求</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="views.html"
                        title="下一章">Writing views</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/topics/http/urls.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">3月 30, 2019</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="index.html" title="处理 HTTP 请求">previous</a>
     |
    <a href="../index.html" title="Using Django" accesskey="U">up</a>
   |
    <a href="views.html" title="Writing views">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>